AWSTemplateFormatVersion: 2010-09-09
Description: GraphQLResolverStack1NestedStack nested stack
Parameters:
  GraphQlDsActionHistoryDataSourceNameParameter:
    Type: String
  GraphQlApiApiIdParameter:
    Type: String
  GraphQlDsAuthorizationDataSourceNameParameter:
    Type: String
  GraphQlDsBackOfficeUserRoleDataSourceNameParameter:
    Type: String
  GraphQlDsBackOfficeUserDataSourceNameParameter:
    Type: String
  GraphQlDsCategoryDataSourceNameParameter:
    Type: String
  GraphQlDsDaySlotDataSourceNameParameter:
    Type: String
  GraphQlDsCenterTypeDataSourceNameParameter:
    Type: String
  GraphQlDsCompanyDataSourceNameParameter:
    Type: String
  GraphQlDsEventDataSourceNameParameter:
    Type: String
  GraphQlDsEventTypeDataSourceNameParameter:
    Type: String
  GraphQlDsCenterDataSourceNameParameter:
    Type: String
  GraphQlDsGroupRoleDataSourceNameParameter:
    Type: String
  GraphQlDsUserDataSourceNameParameter:
    Type: String
  GraphQlDsLikeDataSourceNameParameter:
    Type: String
  GraphQlDsOperatorDataSourceNameParameter:
    Type: String
  GraphQlDsOrderItemDataSourceNameParameter:
    Type: String
  GraphQlDsAttributeDataSourceNameParameter:
    Type: String
  GraphQlDsPaymentDataSourceNameParameter:
    Type: String
  GraphQlDsProductDataSourceNameParameter:
    Type: String
  GraphQlDsUnavailabilityDataSourceNameParameter:
    Type: String
  GraphQlDsProviderServiceDataSourceNameParameter:
    Type: String
  GraphQlDsUserRoleDataSourceNameParameter:
    Type: String
  GraphQlDsUserRoleUserDataSourceNameParameter:
    Type: String
  GraphQlDsElasticSearchDataSourceNameParameter:
    Type: String
Resources:
  GraphQlResolverQuerylistActionHistorys:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: listActionHistorys
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $ListRequest = {
          "version": "2017-02-28",
          "limit": $limit
        } )
        #if( $context.args.nextToken )
          #set( $ListRequest.nextToken = "$context.args.nextToken" )
        #end
        #if( $context.args.filter )
          #set( $ListRequest.filter = $util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)") )
        #end
        #if( !$util.isNull($modelQueryExpression)
                                && !$util.isNullOrEmpty($modelQueryExpression.expression) )
          $util.qr($ListRequest.put("operation", "Query"))
          $util.qr($ListRequest.put("query", $modelQueryExpression))
          #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == "DESC" )
            #set( $ListRequest.scanIndexForward = false )
          #else
            #set( $ListRequest.scanIndexForward = true )
          #end
        #else
          $util.qr($ListRequest.put("operation", "Scan"))
        #end
        $util.toJson($ListRequest)
      ResponseMappingTemplate: $util.toJson($ctx.result)
      DataSourceName: !Ref GraphQlDsActionHistoryDataSourceNameParameter
  GraphQlResolverQuerygetAuthorization:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: getAuthorization
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
        } #end
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsAuthorizationDataSourceNameParameter
  GraphQlResolverBackOfficeUserroles:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: BackOfficeUser
      FieldName: roles
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "backOfficeUserRoleBackOfficeUserUserId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-BackOfficeUserBackOfficeUserRole"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsBackOfficeUserRoleDataSourceNameParameter
  GraphQlResolverBackOfficeUserRoleusers:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: BackOfficeUserRole
      FieldName: users
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "backOfficeUserRoleBackOfficeUserRoleId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-BackOfficeUserRoleBackOfficeUser"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsBackOfficeUserDataSourceNameParameter
  GraphQlResolverMutationcreateCategory:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Mutation
      FieldName: createCategory
      RequestMappingTemplate: >-
        ## [Start] Prepare DynamoDB PutItem Request. **

        $util.qr($context.args.input.put("createdAt",
        $util.defaultIfNull($ctx.args.input.createdAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("updatedAt",
        $util.defaultIfNull($ctx.args.input.updatedAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("__typename", "Category"))

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": {
              "expression": "attribute_not_exists(#id)",
              "expressionNames": {
                  "#id": "id"
            }
          }
        }

        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsCategoryDataSourceNameParameter
  GraphQlResolverCenterdaySlots:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Center
      FieldName: daySlots
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "centerDaySlotsId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-Center.daySlots"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsDaySlotDataSourceNameParameter
  GraphQlResolverMutationcreateCenterType:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Mutation
      FieldName: createCenterType
      RequestMappingTemplate: >-
        ## [Start] Prepare DynamoDB PutItem Request. **

        $util.qr($context.args.input.put("createdAt",
        $util.defaultIfNull($ctx.args.input.createdAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("updatedAt",
        $util.defaultIfNull($ctx.args.input.updatedAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("__typename", "CenterType"))

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": {
              "expression": "attribute_not_exists(#id)",
              "expressionNames": {
                  "#id": "id"
            }
          }
        }

        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsCenterTypeDataSourceNameParameter
  GraphQlResolverQuerylistCompanys:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: listCompanys
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $ListRequest = {
          "version": "2017-02-28",
          "limit": $limit
        } )
        #if( $context.args.nextToken )
          #set( $ListRequest.nextToken = "$context.args.nextToken" )
        #end
        #if( $context.args.filter )
          #set( $ListRequest.filter = $util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)") )
        #end
        #if( !$util.isNull($modelQueryExpression)
                                && !$util.isNullOrEmpty($modelQueryExpression.expression) )
          $util.qr($ListRequest.put("operation", "Query"))
          $util.qr($ListRequest.put("query", $modelQueryExpression))
          #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == "DESC" )
            #set( $ListRequest.scanIndexForward = false )
          #else
            #set( $ListRequest.scanIndexForward = true )
          #end
        #else
          $util.qr($ListRequest.put("operation", "Scan"))
        #end
        $util.toJson($ListRequest)
      ResponseMappingTemplate: $util.toJson($ctx.result)
      DataSourceName: !Ref GraphQlDsCompanyDataSourceNameParameter
  GraphQlResolverQuerygetEvent:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: getEvent
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
        } #end
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsEventDataSourceNameParameter
  GraphQlResolverQuerylistEventTypes:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: listEventTypes
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $ListRequest = {
          "version": "2017-02-28",
          "limit": $limit
        } )
        #if( $context.args.nextToken )
          #set( $ListRequest.nextToken = "$context.args.nextToken" )
        #end
        #if( $context.args.filter )
          #set( $ListRequest.filter = $util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)") )
        #end
        #if( !$util.isNull($modelQueryExpression)
                                && !$util.isNullOrEmpty($modelQueryExpression.expression) )
          $util.qr($ListRequest.put("operation", "Query"))
          $util.qr($ListRequest.put("query", $modelQueryExpression))
          #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == "DESC" )
            #set( $ListRequest.scanIndexForward = false )
          #else
            #set( $ListRequest.scanIndexForward = true )
          #end
        #else
          $util.qr($ListRequest.put("operation", "Scan"))
        #end
        $util.toJson($ListRequest)
      ResponseMappingTemplate: $util.toJson($ctx.result)
      DataSourceName: !Ref GraphQlDsEventTypeDataSourceNameParameter
  GraphQlResolverGlobalOrdercenter:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: GlobalOrder
      FieldName: center
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": {
              "id": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.globalOrderCenterId, "___xamznone____"))
          }
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsCenterDataSourceNameParameter
  GraphQlResolverGroupbackOfficeUsers:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Group
      FieldName: backOfficeUsers
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "groupBackOfficeUserGroupId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-GroupBackOfficeUser"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsBackOfficeUserDataSourceNameParameter
  GraphQlResolverQuerylistGroupRoles:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: listGroupRoles
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $ListRequest = {
          "version": "2017-02-28",
          "limit": $limit
        } )
        #if( $context.args.nextToken )
          #set( $ListRequest.nextToken = "$context.args.nextToken" )
        #end
        #if( $context.args.filter )
          #set( $ListRequest.filter = $util.parseJson("$util.transform.toDynamoDBFilterExpression($ctx.args.filter)") )
        #end
        #if( !$util.isNull($modelQueryExpression)
                                && !$util.isNullOrEmpty($modelQueryExpression.expression) )
          $util.qr($ListRequest.put("operation", "Query"))
          $util.qr($ListRequest.put("query", $modelQueryExpression))
          #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == "DESC" )
            #set( $ListRequest.scanIndexForward = false )
          #else
            #set( $ListRequest.scanIndexForward = true )
          #end
        #else
          $util.qr($ListRequest.put("operation", "Scan"))
        #end
        $util.toJson($ListRequest)
      ResponseMappingTemplate: $util.toJson($ctx.result)
      DataSourceName: !Ref GraphQlDsGroupRoleDataSourceNameParameter
  GraphQlResolverHighlightauthor:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Highlight
      FieldName: author
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": {
              "id": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.highlightAuthorId, "___xamznone____"))
          }
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsUserDataSourceNameParameter
  GraphQlResolverMutationcreateLike:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Mutation
      FieldName: createLike
      RequestMappingTemplate: >-
        ## [Start] Prepare DynamoDB PutItem Request. **

        $util.qr($context.args.input.put("createdAt",
        $util.defaultIfNull($ctx.args.input.createdAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("updatedAt",
        $util.defaultIfNull($ctx.args.input.updatedAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("__typename", "Like"))

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": {
              "expression": "attribute_not_exists(#id)",
              "expressionNames": {
                  "#id": "id"
            }
          }
        }

        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsLikeDataSourceNameParameter
  GraphQlResolverQuerygetOperator:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: getOperator
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
        } #end
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsOperatorDataSourceNameParameter
  GraphQlResolverOperatorcenterTypes:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Operator
      FieldName: centerTypes
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "centerTypeOperatorId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-OperatorCenterTypes"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsCenterTypeDataSourceNameParameter
  GraphQlResolverOrderorderItems:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Order
      FieldName: orderItems
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "orderOrderItemsId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-Order.orderItems"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsOrderItemDataSourceNameParameter
  GraphQlResolverOrderItemattributes:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: OrderItem
      FieldName: attributes
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "orderItemAttributesId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-OrderItem.attributes"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsAttributeDataSourceNameParameter
  GraphQlResolverMutationcreatePayment:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Mutation
      FieldName: createPayment
      RequestMappingTemplate: >-
        ## [Start] Prepare DynamoDB PutItem Request. **

        $util.qr($context.args.input.put("createdAt",
        $util.defaultIfNull($ctx.args.input.createdAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("updatedAt",
        $util.defaultIfNull($ctx.args.input.updatedAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("__typename", "Payment"))

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": {
              "expression": "attribute_not_exists(#id)",
              "expressionNames": {
                  "#id": "id"
            }
          }
        }

        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsPaymentDataSourceNameParameter
  GraphQlResolverMutationcreateProduct:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Mutation
      FieldName: createProduct
      RequestMappingTemplate: >-
        ## [Start] Prepare DynamoDB PutItem Request. **

        $util.qr($context.args.input.put("createdAt",
        $util.defaultIfNull($ctx.args.input.createdAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("updatedAt",
        $util.defaultIfNull($ctx.args.input.updatedAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("__typename", "Product"))

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": {
              "expression": "attribute_not_exists(#id)",
              "expressionNames": {
                  "#id": "id"
            }
          }
        }

        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsProductDataSourceNameParameter
  GraphQlResolverProductunavailabilities:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Product
      FieldName: unavailabilities
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "unavailabilityProductId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-UnavailabilityProduct"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsUnavailabilityDataSourceNameParameter
  GraphQlResolverMutationcreateProviderService:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Mutation
      FieldName: createProviderService
      RequestMappingTemplate: >-
        ## [Start] Prepare DynamoDB PutItem Request. **

        $util.qr($context.args.input.put("createdAt",
        $util.defaultIfNull($ctx.args.input.createdAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("updatedAt",
        $util.defaultIfNull($ctx.args.input.updatedAt,
        $util.time.nowISO8601())))

        $util.qr($context.args.input.put("__typename", "ProviderService"))

        {
          "version": "2017-02-28",
          "operation": "PutItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id":   $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.args.input.id, $util.autoId()))
        } #end,
          "attributeValues": $util.dynamodb.toMapValuesJson($context.args.input),
          "condition": {
              "expression": "attribute_not_exists(#id)",
              "expressionNames": {
                  "#id": "id"
            }
          }
        }

        ## [End] Prepare DynamoDB PutItem Request. **
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsProviderServiceDataSourceNameParameter
  GraphQlResolverServicecategory:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Service
      FieldName: category
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": {
              "id": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.serviceCategoryId, "___xamznone____"))
          }
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsCategoryDataSourceNameParameter
  GraphQlResolverUnavailabilityuser:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Unavailability
      FieldName: user
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": {
              "id": $util.dynamodb.toDynamoDBJson($util.defaultIfNullOrBlank($ctx.source.unavailabilityUserId, "___xamznone____"))
          }
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsUserDataSourceNameParameter
  GraphQlResolverUserroles:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: User
      FieldName: roles
      RequestMappingTemplate: |-
        #set( $limit = $util.defaultIfNull($context.args.limit, 10) )
        #set( $query = {
          "expression": "#connectionAttribute = :connectionAttribute",
          "expressionNames": {
              "#connectionAttribute": "userRoleUserUserId"
          },
          "expressionValues": {
              ":connectionAttribute": {
                  "S": "$context.source.id"
            }
          }
        } )
        {
          "version": "2017-02-28",
          "operation": "Query",
          "query":   $util.toJson($query),
          "scanIndexForward":   #if( $context.args.sortDirection )
            #if( $context.args.sortDirection == "ASC" )
        true
            #else
        false
            #end
          #else
        true
          #end,
          "filter":   #if( $context.args.filter )
        $util.transform.toDynamoDBFilterExpression($ctx.args.filter)
          #else
        null
          #end,
          "limit": $limit,
          "nextToken":   #if( $context.args.nextToken )
        "$context.args.nextToken"
          #else
        null
          #end,
          "index": "gsi-UserUserRole"
        }
      ResponseMappingTemplate: |-
        #if( !$result )
          #set( $result = $ctx.result )
        #end
        $util.toJson($result)
      DataSourceName: !Ref GraphQlDsUserRoleDataSourceNameParameter
  GraphQlResolverQuerygetUserRoleUser:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: getUserRoleUser
      RequestMappingTemplate: |-
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {
          "id": $util.dynamodb.toDynamoDBJson($ctx.args.id)
        } #end
        }
      ResponseMappingTemplate: $util.toJson($context.result)
      DataSourceName: !Ref GraphQlDsUserRoleUserDataSourceNameParameter
  GraphQlResolverQuerysearchCenters:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: searchCenters
      RequestMappingTemplate: >-
        #set( $indexPath = "/grdcenter-dev/doc/_search" )

        #set( $nonKeywordFields = ["vat", "authorized", "enabled",
        "markForDelete"] )

        #if( $util.isNullOrEmpty($context.args.sort) )
          #set( $sortDirection = "desc" )
          #set( $sortField = "id" )
        #else
          #set( $sortDirection = $util.defaultIfNull($context.args.sort.direction, "desc") )
          #set( $sortField = $util.defaultIfNull($context.args.sort.field, "id") )
        #end

        {
          "version": "2017-02-28",
          "operation": "GET",
          "path": "$indexPath",
          "params": {
              "body":     {
                        #if( $context.args.nextToken )"search_after": ["$context.args.nextToken"], #end
                        "size": #if( $context.args.limit ) $context.args.limit #else 10 #end,
                        "sort": [{ #if($nonKeywordFields.contains($sortField))    "$sortField" #else "${sortField}.keyword" #end : {    "order" : "$sortDirection"} }],
                        "query": #if( $context.args.filter )
        $util.transform.toElasticsearchQueryDSL($ctx.args.filter)

        #else

        {
              "match_all": {}
          }
        #end
                        }
          }
        }
      ResponseMappingTemplate: |-
        #set( $es_items = [] )
        #foreach( $entry in $context.result.hits.hits )
          #if( !$foreach.hasNext )
            #set( $nextToken = $entry.sort.get(0) )
          #end
          $util.qr($es_items.add($entry.get("_source")))
        #end
        $util.toJson({
          "items": $es_items,
          "total": $ctx.result.hits.total,
          "nextToken": $nextToken
        })
      DataSourceName: !Ref GraphQlDsElasticSearchDataSourceNameParameter
  GraphQlResolverQuerysearchUsers:
    Type: 'AWS::AppSync::Resolver'
    DependsOn: []
    Properties:
      ApiId: !Ref GraphQlApiApiIdParameter
      TypeName: Query
      FieldName: searchUsers
      RequestMappingTemplate: |-
        #set( $indexPath = "/grduser-dev/doc/_search" )
        #set( $nonKeywordFields = ["enabled", "markForDelete"] )
        #if( $util.isNullOrEmpty($context.args.sort) )
          #set( $sortDirection = "desc" )
          #set( $sortField = "id" )
        #else
          #set( $sortDirection = $util.defaultIfNull($context.args.sort.direction, "desc") )
          #set( $sortField = $util.defaultIfNull($context.args.sort.field, "id") )
        #end
        {
          "version": "2017-02-28",
          "operation": "GET",
          "path": "$indexPath",
          "params": {
              "body":     {
                        #if( $context.args.nextToken )"search_after": ["$context.args.nextToken"], #end
                        "size": #if( $context.args.limit ) $context.args.limit #else 10 #end,
                        "sort": [{ #if($nonKeywordFields.contains($sortField))    "$sortField" #else "${sortField}.keyword" #end : {    "order" : "$sortDirection"} }],
                        "query": #if( $context.args.filter )
        $util.transform.toElasticsearchQueryDSL($ctx.args.filter)
        #else
        {
              "match_all": {}
          }
        #end
                        }
          }
        }
      ResponseMappingTemplate: |-
        #set( $es_items = [] )
        #foreach( $entry in $context.result.hits.hits )
          #if( !$foreach.hasNext )
            #set( $nextToken = $entry.sort.get(0) )
          #end
          $util.qr($es_items.add($entry.get("_source")))
        #end
        $util.toJson({
          "items": $es_items,
          "total": $ctx.result.hits.total,
          "nextToken": $nextToken
        })
      DataSourceName: !Ref GraphQlDsElasticSearchDataSourceNameParameter
Outputs: {}
